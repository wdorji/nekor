"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AudioReporter = void 0;
const play_sound_1 = __importDefault(require("play-sound"));
const rc_1 = __importDefault(require("rc"));
const log_1 = require("./log");
const options_1 = require("./options");
const store_1 = require("./store");
class AudioReporter {
    constructor(globalConfig, jestOptions) {
        this.globalConfig = globalConfig;
        this.log = (0, log_1.createLog)();
        if (jestOptions.debug) {
            this.log.enabled = true;
        }
        this.player = (0, play_sound_1.default)({});
        this.disable = !!jestOptions.disable;
        this.volume = jestOptions.volume;
        this.onStartVolume = jestOptions.onStartVolume || 0.5;
        this.onCompleteVolume = jestOptions.onCompleteVolume;
        const rawRCOptions = (0, rc_1.default)('jest-audio-reporter');
        const rcOptions = (0, options_1.processOptions)(rawRCOptions);
        (0, log_1.logOptions)({ log: this.log }, rawRCOptions, rcOptions);
        this.options = rcOptions;
    }
    onRunStart(results, options) {
        if (this.disable)
            return;
        if (store_1.store.completeAudio) {
            store_1.store.completeAudio.kill();
            store_1.store.completeAudio = undefined;
        }
        if (results.numTotalTestSuites === 0 ||
            options.estimatedTime > 0 &&
                options.estimatedTime <= this.options.onStartThreshold)
            return;
        const file = pickOne(this.options.onStart);
        const volume = this.getEffectiveOnStartVolume();
        store_1.store.startAudio = this.player.play(file, this.getPlayOption({ volume }));
    }
    onRunComplete(_contexts, results) {
        if (this.disable)
            return;
        if (store_1.store.startAudio) {
            store_1.store.startAudio.kill();
            store_1.store.startAudio = undefined;
        }
        if (results.numTotalTestSuites === 0)
            return;
        if (results.wasInterrupted)
            return;
        if (results.numFailedTestSuites === 0) {
            if (isWatch(this.globalConfig) && store_1.store.doesLastRunPass)
                return;
            store_1.store.doesLastRunPass = true;
            return this.playComplete(pickOne(this.options.onSuitePass));
        }
        else {
            store_1.store.doesLastRunPass = false;
            return this.playComplete(pickOne(this.options.onSuiteFailure));
        }
    }
    playComplete(file) {
        if (!file)
            return;
        const volume = this.getEffectiveOnCompleteVolume();
        if (isWatch(this.globalConfig)) {
            store_1.store.completeAudio = this.player.play(file, this.getPlayOption({ volume }));
        }
        else {
            return new Promise(a => {
                store_1.store.completeAudio = this.player.play(file, this.getPlayOption({ volume }), a);
            });
        }
    }
    getEffectiveOnStartVolume() {
        return Math.min(this.volume || 1, this.onStartVolume);
    }
    getEffectiveOnCompleteVolume() {
        return Math.min(this.volume || 1, this.onCompleteVolume || 1);
    }
    getPlayOption(option) {
        switch (this.player.player) {
            case 'afplay':
                return getAfPlayOption(option);
            case 'mplayer':
                return getMplayerOption(option);
            default:
                return {};
        }
    }
}
exports.AudioReporter = AudioReporter;
function pickOne(arr) {
    if (arr.length === 0)
        return undefined;
    return arr[Math.floor(Math.random() * arr.length)];
}
function isWatch(globalConfig) {
    return globalConfig.watch || globalConfig.watchAll;
}
function getAfPlayOption({ volume }) {
    // https://ss64.com/osx/afplay.html
    // According to the link, the volume is logarithmic,
    // but I'm not sure what does it mean, as:
    // log(1) = 0
    // log(0.1) = -1
    // log(0) = -infinity
    // So for now, I treat [0, 1] as linear
    return { afplay: ['-v', 1 / (Math.pow(10, Math.log2(1 / volume)))] };
}
function getMplayerOption({ volume }) {
    // http://www.mplayerhq.hu/DOCS/man/en/mplayer.1.html search for "-volume"
    return { mplayer: ['-volume', volume * 100] };
}
//# sourceMappingURL=AudioReporter.js.map